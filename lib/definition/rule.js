"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return RuleDefinition;
    }
});
const _occamlexers = require("occam-lexers");
const _definition = /*#__PURE__*/ _interop_require_default(require("../definition"));
const _ruleName = /*#__PURE__*/ _interop_require_default(require("../part/nonTerminal/ruleName"));
const _optionalPart = /*#__PURE__*/ _interop_require_default(require("../part/nonTerminal/optionalPart"));
const _stringLiteral = /*#__PURE__*/ _interop_require_default(require("../part/terminal/stringLiteral"));
const _ruleNames = require("../ruleNames");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const { separator, terminator } = _occamlexers.specialSymbols;
class RuleDefinition extends _definition.default {
    static fromNothing() {
        let ruleName;
        const separatorStringLiteralContent = separator, terminatorStringLiteralContent = terminator; ///
        ruleName = _ruleNames.OPACITY_MODIFIER_RULE_NAME;
        const opacityModifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NAME_RULE_NAME;
        const nameRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalOpacityRuleNamePartPart = _optionalPart.default.fromPart(opacityModifierRuleNamePart), separatorStringLiteralPart = _stringLiteral.default.fromContent(separatorStringLiteralContent);
        ruleName = _ruleNames.DEFINITIONS_RULE_NAME;
        const definitionsRuleNamePart = _ruleName.default.fromRuleName(ruleName), terminatorStringLiteralPart = _stringLiteral.default.fromContent(terminatorStringLiteralContent), parts = [
            nameRuleNamePart,
            optionalOpacityRuleNamePartPart,
            separatorStringLiteralPart,
            definitionsRuleNamePart,
            terminatorStringLiteralPart
        ], precedence = null, ruleDefinition = new RuleDefinition(parts, precedence);
        return ruleDefinition;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWZpbml0aW9uL3J1bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IE9wdGlvbmFsUGFydFBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5pbXBvcnQgeyBOQU1FX1JVTEVfTkFNRSwgREVGSU5JVElPTlNfUlVMRV9OQU1FLCBPUEFDSVRZX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyBzZXBhcmF0b3IsIHRlcm1pbmF0b3IgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbENvbnRlbnQgPSBzZXBhcmF0b3IsIC8vL1xuICAgICAgICAgIHRlcm1pbmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCA9IHRlcm1pbmF0b3I7IC8vL1xuXG4gICAgcnVsZU5hbWUgPSBPUEFDSVRZX01PRElGSUVSX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IG9wYWNpdHlNb2RpZmllclJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBOQU1FX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IG5hbWVSdWxlTmFtZVBhcnQgPSBSdWxlTmFtZVBhcnQuZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICBvcHRpb25hbE9wYWNpdHlSdWxlTmFtZVBhcnRQYXJ0ID0gT3B0aW9uYWxQYXJ0UGFydC5mcm9tUGFydChvcGFjaXR5TW9kaWZpZXJSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHNlcGFyYXRvclN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbENvbnRlbnQpO1xuXG4gICAgcnVsZU5hbWUgPSBERUZJTklUSU9OU19SVUxFX05BTUU7XG5cbiAgICBjb25zdCBkZWZpbml0aW9uc1J1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHRlcm1pbmF0b3JTdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KHRlcm1pbmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBuYW1lUnVsZU5hbWVQYXJ0LFxuICAgICAgICAgICAgb3B0aW9uYWxPcGFjaXR5UnVsZU5hbWVQYXJ0UGFydCxcbiAgICAgICAgICAgIHNlcGFyYXRvclN0cmluZ0xpdGVyYWxQYXJ0LFxuICAgICAgICAgICAgZGVmaW5pdGlvbnNSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB0ZXJtaW5hdG9yU3RyaW5nTGl0ZXJhbFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHJ1bGVEZWZpbml0aW9uID0gbmV3IFJ1bGVEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBydWxlRGVmaW5pdGlvbjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlJ1bGVEZWZpbml0aW9uIiwic2VwYXJhdG9yIiwidGVybWluYXRvciIsInNwZWNpYWxTeW1ib2xzIiwiRGVmaW5pdGlvbiIsImZyb21Ob3RoaW5nIiwicnVsZU5hbWUiLCJzZXBhcmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCIsInRlcm1pbmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCIsIk9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FIiwib3BhY2l0eU1vZGlmaWVyUnVsZU5hbWVQYXJ0IiwiUnVsZU5hbWVQYXJ0IiwiZnJvbVJ1bGVOYW1lIiwiTkFNRV9SVUxFX05BTUUiLCJuYW1lUnVsZU5hbWVQYXJ0Iiwib3B0aW9uYWxPcGFjaXR5UnVsZU5hbWVQYXJ0UGFydCIsIk9wdGlvbmFsUGFydFBhcnQiLCJmcm9tUGFydCIsInNlcGFyYXRvclN0cmluZ0xpdGVyYWxQYXJ0IiwiU3RyaW5nTGl0ZXJhbFBhcnQiLCJmcm9tQ29udGVudCIsIkRFRklOSVRJT05TX1JVTEVfTkFNRSIsImRlZmluaXRpb25zUnVsZU5hbWVQYXJ0IiwidGVybWluYXRvclN0cmluZ0xpdGVyYWxQYXJ0IiwicGFydHMiLCJwcmVjZWRlbmNlIiwicnVsZURlZmluaXRpb24iXSwibWFwcGluZ3MiOiJBQUFBOzs7OytCQWFBOzs7ZUFBcUJBOzs7NkJBWFU7bUVBRVI7aUVBQ0U7cUVBQ0k7c0VBQ0M7MkJBRW9EOzs7Ozs7QUFFbEYsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRSxHQUFHQywyQkFBYztBQUVqQyxNQUFNSCx1QkFBdUJJLG1CQUFVO0lBQ3BELE9BQU9DLGNBQWM7UUFDbkIsSUFBSUM7UUFFSixNQUFNQyxnQ0FBZ0NOLFdBQ2hDTyxpQ0FBaUNOLFlBQVksR0FBRztRQUV0REksV0FBV0cscUNBQTBCO1FBRXJDLE1BQU1DLDhCQUE4QkMsaUJBQVksQ0FBQ0MsWUFBWSxDQUFDTjtRQUU5REEsV0FBV08seUJBQWM7UUFFekIsTUFBTUMsbUJBQW1CSCxpQkFBWSxDQUFDQyxZQUFZLENBQUNOLFdBQzdDUyxrQ0FBa0NDLHFCQUFnQixDQUFDQyxRQUFRLENBQUNQLDhCQUM1RFEsNkJBQTZCQyxzQkFBaUIsQ0FBQ0MsV0FBVyxDQUFDYjtRQUVqRUQsV0FBV2UsZ0NBQXFCO1FBRWhDLE1BQU1DLDBCQUEwQlgsaUJBQVksQ0FBQ0MsWUFBWSxDQUFDTixXQUNwRGlCLDhCQUE4Qkosc0JBQWlCLENBQUNDLFdBQVcsQ0FBQ1osaUNBQzVEZ0IsUUFBUTtZQUNOVjtZQUNBQztZQUNBRztZQUNBSTtZQUNBQztTQUNELEVBQ0RFLGFBQWEsTUFDYkMsaUJBQWlCLElBQUkxQixlQUFld0IsT0FBT0M7UUFFakQsT0FBT0M7SUFDVDtBQUNGIn0=