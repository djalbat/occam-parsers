"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return PrecedenceDefinition;
    }
});
const _occamlexers = require("occam-lexers");
const _definition = /*#__PURE__*/ _interop_require_default(require("../definition"));
const _optionalPart = /*#__PURE__*/ _interop_require_default(require("../part/nonTerminal/optionalPart"));
const _stringLiteral = /*#__PURE__*/ _interop_require_default(require("../part/terminal/stringLiteral"));
const _significantTokenType = /*#__PURE__*/ _interop_require_default(require("../part/terminal/significantTokenType"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const { numberType } = _occamlexers.types, { openBracket, closeBracket } = _occamlexers.specialSymbols;
class PrecedenceDefinition extends _definition.default {
    static fromNothing() {
        const significantTokenType = numberType, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent), numberSignificantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), optionalNumberSignificantTokenTypePartPart = _optionalPart.default.fromPart(numberSignificantTokenTypePart), parts = [
            openBracketStringLiteralPart,
            optionalNumberSignificantTokenTypePartPart,
            closeBracketStringLiteralPart
        ], precedence = null, precedenceDefinition = new PrecedenceDefinition(parts, precedence);
        return precedenceDefinition;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWZpbml0aW9uL3ByZWNlZGVuY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzLCBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBPcHRpb25hbFBhcnRQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxQYXJ0IGZyb20gXCIuLi9wYXJ0L3Rlcm1pbmFsL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuY29uc3QgeyBudW1iZXJUeXBlIH0gPSB0eXBlcyxcbiAgICAgIHsgb3BlbkJyYWNrZXQsIGNsb3NlQnJhY2tldCB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZWNlZGVuY2VEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZSA9IG51bWJlclR5cGUsICAvLy9cbiAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50ID0gb3BlbkJyYWNrZXQsIC8vL1xuICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50ID0gY2xvc2VCcmFja2V0LCAvLy9cbiAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQob3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCksXG4gICAgICAgICAgY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCksXG4gICAgICAgICAgbnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmZyb21TaWduaWZpY2FudFRva2VuVHlwZShzaWduaWZpY2FudFRva2VuVHlwZSksXG4gICAgICAgICAgb3B0aW9uYWxOdW1iZXJTaWduaWZpY2FudFRva2VuVHlwZVBhcnRQYXJ0ID0gT3B0aW9uYWxQYXJ0UGFydC5mcm9tUGFydChudW1iZXJTaWduaWZpY2FudFRva2VuVHlwZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCxcbiAgICAgICAgICAgIG9wdGlvbmFsTnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0UGFydCxcbiAgICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBwcmVjZWRlbmNlRGVmaW5pdGlvbiA9IG5ldyBQcmVjZWRlbmNlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gcHJlY2VkZW5jZURlZmluaXRpb247XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJQcmVjZWRlbmNlRGVmaW5pdGlvbiIsIm51bWJlclR5cGUiLCJ0eXBlcyIsIm9wZW5CcmFja2V0IiwiY2xvc2VCcmFja2V0Iiwic3BlY2lhbFN5bWJvbHMiLCJEZWZpbml0aW9uIiwiZnJvbU5vdGhpbmciLCJzaWduaWZpY2FudFRva2VuVHlwZSIsIm9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbENvbnRlbnQiLCJjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCIsIm9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQiLCJTdHJpbmdMaXRlcmFsUGFydCIsImZyb21Db250ZW50IiwiY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQiLCJudW1iZXJTaWduaWZpY2FudFRva2VuVHlwZVBhcnQiLCJTaWduaWZpY2FudFRva2VuVHlwZVBhcnQiLCJmcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUiLCJvcHRpb25hbE51bWJlclNpZ25pZmljYW50VG9rZW5UeXBlUGFydFBhcnQiLCJPcHRpb25hbFBhcnRQYXJ0IiwiZnJvbVBhcnQiLCJwYXJ0cyIsInByZWNlZGVuY2UiLCJwcmVjZWRlbmNlRGVmaW5pdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7K0JBWUE7OztlQUFxQkE7Ozs2QkFWaUI7bUVBRWY7cUVBQ007c0VBQ0M7NkVBQ087Ozs7OztBQUVyQyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHQyxrQkFBSyxFQUN0QixFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRSxHQUFHQywyQkFBYztBQUVyQyxNQUFNTCw2QkFBNkJNLG1CQUFVO0lBQzFELE9BQU9DLGNBQWM7UUFDbkIsTUFBTUMsdUJBQXVCUCxZQUN2QlEsa0NBQWtDTixhQUNsQ08sbUNBQW1DTixjQUNuQ08sK0JBQStCQyxzQkFBaUIsQ0FBQ0MsV0FBVyxDQUFDSixrQ0FDN0RLLGdDQUFnQ0Ysc0JBQWlCLENBQUNDLFdBQVcsQ0FBQ0gsbUNBQzlESyxpQ0FBaUNDLDZCQUF3QixDQUFDQyx3QkFBd0IsQ0FBQ1QsdUJBQ25GVSw2Q0FBNkNDLHFCQUFnQixDQUFDQyxRQUFRLENBQUNMLGlDQUN2RU0sUUFBUTtZQUNOVjtZQUNBTztZQUNBSjtTQUNELEVBQ0RRLGFBQWEsTUFDYkMsdUJBQXVCLElBQUl2QixxQkFBcUJxQixPQUFPQztRQUU3RCxPQUFPQztJQUNUO0FBQ0YifQ==